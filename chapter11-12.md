# 11장 - 12장 정리

## 원시값
* 원시값(원시 타입의 값)의 값은 변경 불가능한 값
* 원시값을 자체를 변경하는 것은 불가능하지만, 변수에 새로운 값을 재할당하는 것은 가능하다.
  ```javascript
  var score = 100;

  // copy 변수에는 score 변수의 값 '100'이 복사되어 할당된다
  var copy = score;

  console.log(score, copy); // 100 100
  console.log(score === copy); // true
  ```
* score와 copy 변수는 숫자 값 100을 갖는다는 점에서 동일하다. 하지만 **두 변수의 값은 다른 메모리 공간에 저장된 별개의 값이다.**
* 그러므로 어느 한쪽에서 재할당을 통해 값을 변경하더라도 서로 간섭할 수 없다.
<br>
<br>

## 객체
* 객체(객체 타입의 값)는 변경 가능한 값
* 객체는 재할당 없이 프로퍼티를 동적으로 추가할 수도 있고 프로퍼티 값을 갱신할 수도 있으며, 프로퍼티 자체를 삭제할 수도 있다.
* 여러 개의 식별자(변수명)가 하나의 객체를 공유할 수 있다. (이러한 특성에 따른 부작용이 발생한다.)
  ```javascript
  var person = {
      name: 'Choi'
  };

  var copy = person;
  ```
  * 원본 person과 사본 copy는 저장된 메모리 주소(주소값)는 다르지만 동일한 참조 값을 갖는다. 
  __(두 가지 모두 동일한 객체를 가리킨다.)__
  * 이것은 __두 개의 식별자가 하나의 객체를 공유__ 한다는 것을 의미한다.
  * 원본 또는 사본 중 어느 한쪽에서 객체를 변경 (변수에 새로운 객체를 재할당하는 것이 아니라 객체의 프로퍼티 값을 변경하거나 프로퍼티를 추가/삭제) 하면 서로 영향을 주고받는다.
  ```javascript
  var person = {
      name: 'Choi'
  };

  var copy = person; // 참조 값 복사
  
  console.log(copy === person); // true

  copy.name = 'hui'; // copy를 통해 객체를 변경한다.
  person.nation = 'Korea'; // person을 통해 객체를 변경한다.

  console.log(person); // {name: 'hui', nation: 'Korea'}
  console.log(copy); // {name: 'hui', nation: 'Korea'}
  // copy와 person은 동일한 객체를 가리킨다.
  // 따라서 어느 한쪽에서 객체를 변경하면 서로 영향을 주고 받는다.
  ```
<br>
<br>

## 함수
* 함수는 객체 타입의 값이다.
* 일련의(하나로 이어지는) 과정을 문으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것이다.
  ```javascript
  // 함수 정의
  function add(x, y) {
    return x + y;
  }

  // 함수 호출
  add(4, 5); // 9
  ```

* 매개변수(파라미터) : 함수 내부로 입력을 전달받는 변수 (위 코드에서 __(x, y)__)
* 인자값(인수, argument) : 함수를 호출할 때 입력하는 값 (위 코드에서 __(4, 5)__)
* 반환값 : 출력하는 값 (위 코드에서 __x + y__)
* 함수를 사용하는 이유는 __여러번 호출__ 할 수 있고 __코드의 재사용__ 이라는 측면에서 매우 유용하다.
* 함수를 정의하는 방법에는 4가지가 있다.
  ```javascript
  function add(x, y) {
    return x + y;
  } // 함수 선언문

  var add = function(x, y) {
    return x + y;
  } // 함수 표현식

  var add = new Function('x', 'y', 'return x + y');
  // Function 생성자 함수

  var add = (x, y) => x + y;
  // 화살표 함수(ES6)
  ```
* 함수 표현식에서 함수 리터럴의 함수 이름은 생략할 수 있다. 이러한 함수를 __익명함수__ 라 한다.
* 함수 표현식의 함수 리터럴은 함수 이름을 생략하는 것이 일반적이다.
* 함수 선언문으로 정의한 함수는 함수 선언문 이전에 호출될 수 있다. 그러나 함수 표현식으로 정의한 함수는 함수 표현식 이전에 호출할 수 없다.
* 함수 선언문으로 정의한 함수와 함수 표현식으로 정의한 함수의 생성 시점이 다르기 때문이다.
* 함수 선언문은 런타임 이전에 자바스크립트 엔진에 의해 먼저 실행된다. 런타임에는 이미 함수 객체가 생성되어 있고 함수 이름과 동일한 식별자에 할당 까지 완료된 상태다. 따라서 함수 선언문 이전에 함수를 참조할 수 있으며 호출할 수도 있다
* 이처럼 __함수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 함수 호이스팅__ 이라 한다.
* 함수 호이스팅과 변수 호이스팅은 미묘한 차이가 있으므로 주의해야 한다.
* 변수 선언문과 함수 선언문은 런타임 이전에 먼저 실행되어 식별자를 생성한다는 점에서 동일하다. 하지만 변수 선언문으로 선언된 변수는 undefined로 초기화되고 함수 선언문을 통해 암묵적으로 생성된 식별자는 함수 객체로 초기화 된다.
* 변수 선언문 이전에 변수를 참조하면 undefined로 평가되지만 함수 선언문으로 정의한 함수를 함수 선언문 이전에 호출하면 함수 호이스팅에 의해 호출이 가능하다.
  ```javascript
  foo(4, 5); // 함수 호이스팅에 의해 호출 가능
  console.log(name); // undefined로 초기화 되어 평가
  

  function foo(a, b) {
    console.log(a + b);
  }

  var name = 'Choi';

  console.log(a, b); // ReferenceError: a is not defined
  // 매개변수는 함수 몸체 내부에서만 참조할 수 있다.
  ```

* 함수 표현식으로 함수를 정의하면 함수 호이스팅이 발생하는 것이 아니라 변수 호이스팅이 발생한다. 따라서 함수 표현식 이전에 함수를 참조하면 undefined로 평가되어 함수를 호출하면 타입에러가 발생한다.
  ```javascript
  foo(4, 5);

  var foo = function(a, b) {
    console.log(a + b); // TypeError
  };
  ```

__의문점__ 
```javascript
var result = foo(4, 5);

function foo(a, b) {
  console.log(a + b);
}

// 왜 9가 콘솔에 찍히죠??....
```

* __즉시 실행 함수__ 는 함수 정의와 동시에 즉시 호출되는 함수를 말한다. 즉시 실행 함수는 단 한번만 호출되며 다시 호출할 수 없다.
  ```javascript
  // 익명 즉시 실행 함수
  (function () {
    var a = 4;
    var b = 5;
    return a + b;
  }());
  ```
* 즉시 실행 함수도 일반 함수처럼 값을 반환할 수 있고 인수를 전달할 수도 있다.
  ```javascript
  // 즉시 실행 함수도 일반 함수처럼 값을 반환할 수 있다.
  var foo = function() {
    var a = 4;
    var b = 5;
    return a + b;
  }());

  console.log(foo); // 20

  // 즉시 실행 함수도 일반 함수처럼 인수를 전달할 수 있다.
  foo = (function (a, b) {
    return a * b;
  }(4, 5));

  console.log(foo); // 20

  var foo = (function (a, b) {
    return a * b;
  }(4, 5));

  console.log(foo(5, 5));
  // 이건 왜 타입에러가 뜨는 거죠 선생님???ㅋㅋㅋ
  ```

* __재귀 함수__ 는 함수가 자기 자신을 호출하는 것이다. 재귀 함수는 반복되는 처리를 위해 사용한다.
  ```javascript
  function counter(n) {
    for (var i = n; i >= 0; i--) {
      console.log(i);
    }
  }

  countdown(10);

  // 반복문 없이 구현할 수 있는 방법 : 재귀 함수 사용
  function counter(n) {
    if ( n < 0 ) {
      console.log(n);
      countdown(n - 1);
    }
  }

  countdown(10);
  ```

* __중첩 함수__ 는 함수 내부에 정의된 함수를 중첩 함수(내부 함수)라 한다. 그리고 중첩 함수를 포함하는 함수는 __외부 함수__ 라 부른다.
* 중첩 함수는 외부 함수 내부에서만 호출할 수 있다.
  ```javascript
  function outer() {
    var x = 1;

    // 중첩 함수
    function inner() {
      var y = 2;
      // 외부 함수의 변수를 참조할 수 있다.
      console.log(x + y); // 3
    }

    inner();
  }

  outer();
  ```

* 함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수를 __콜백 함수__ 라고 하며, 매개 변수를 통해 함수의 외부에서 콜백 함수를 전달받은 함수를 __고차 함수__ 라고 한다.
* __순수 함수와 비순수 함수__

#### 순수 함수와 비순수 함수는 좀 더 학습해야 함.